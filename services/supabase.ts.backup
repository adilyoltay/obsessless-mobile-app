import { createClient, SupabaseClient, User, Session } from '@supabase/supabase-js';
import AsyncStorage from '@react-native-async-storage/async-storage';
// import { GoogleSignin } from '@react-native-google-signin/google-signin'; // Temporarily disabled

const SUPABASE_URL = process.env.EXPO_PUBLIC_SUPABASE_URL || 'https://ncniotnzoirwuwwxnipw.supabase.co';
const SUPABASE_ANON_KEY = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5jbmlvdG56b2lyd3V3d3huaXB3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzODA2MjIsImV4cCI6MjA2ODk1NjYyMn0.Ks0vevUbys_gGMbYSlTjzqfWXXikAQ74VTJbzCRcbhk';

console.log('üîê Supabase Config:', {
  url: SUPABASE_URL,
  hasKey: !!SUPABASE_ANON_KEY
});

// Remove the error throwing for now
// if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
//   throw new Error('Missing Supabase environment variables. Please check your .env file.');
// }

// Database Types
export interface UserProfile {
  id: string;
  email: string;
  name: string;
  provider: 'email' | 'google';
  created_at: string;
  updated_at: string;
}

export interface UserProfileCreate {
  ocd_symptoms?: string[];
  daily_goal?: number;
  ybocs_score?: number;
  ybocs_severity?: string;
  onboarding_completed?: boolean;
}

export interface OCDProfile {
  id: string;
  user_id: string;
  ocd_symptoms: string[];
  daily_goal: number;
  ybocs_score: number;
  ybocs_severity: string;
  onboarding_completed: boolean;
  created_at: string;
}

export interface CompulsionRecord {
  id: string;
  user_id: string;
  category: string;
  subcategory?: string;
  resistance_level: number;
  trigger?: string;
  notes?: string;
  timestamp: string;
}

export interface ERPSession {
  id: string;
  user_id: string;
  exercise_id: string;
  exercise_name: string;
  category: string;
  duration_seconds: number;
  anxiety_initial: number;
  anxiety_final: number;
  anxiety_readings: any[];
  completed: boolean;
  timestamp: string;
}

export interface GamificationProfile {
  id: string;
  user_id: string;
  healing_points_total: number;
  healing_points_today: number;
  streak_count: number;
  streak_last_update: string;
  level: number;
  achievements: string[];
  micro_rewards: any[];
  updated_at: string;
}

class SupabaseService {
  private client: SupabaseClient;
  private currentUser: User | null = null;

  constructor() {
    this.client = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        storage: AsyncStorage,
        autoRefreshToken: true,
        persistSession: true,
        detectSessionInUrl: false,
      },
    });
    this.client.auth.onAuthStateChange((event: any, session: any) => {
      console.log('üîê Supabase auth state changed:', event);
      this.currentUser = session?.user || null;
    });
  }

  // Initialize and get current session
  async initialize(): Promise<User | null> {
    try {
      const { data: { session } } = await this.client.auth.getSession();
      this.currentUser = session?.user || null;
      return this.currentUser;
    } catch (error) {
      console.error('‚ùå Supabase initialization failed:', error);
      return null;
    }
  }

  // Auth Methods
  async signUpWithEmail(email: string, password: string, name: string) {
    try {
      // Stricter email validation to match Supabase requirements
      const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
      if (!emailRegex.test(email)) {
        throw new Error('Ge√ßerli bir email adresi girin (√∂rn: user@gmail.com)');
      }

      // Additional validation for common invalid formats
      if (email.includes('..') || email.startsWith('.') || email.endsWith('.')) {
        throw new Error('Email formatƒ± ge√ßersiz');
      }

      console.log('üìß Email validation passed:', email);

      const { data, error } = await this.client.auth.signUp({
        email,
        password,
        options: {
          data: {
            name,
            provider: 'email'
          }
        }
      });

      if (error) throw error;

      // User profile automatically created by Supabase trigger
      console.log('‚úÖ Email signup successful:', email);
      console.log('‚úÖ User profile will be created by trigger');
      
      return data;
    } catch (error) {
      console.error('‚ùå Email signup failed:', error);
      throw error;
    }
  }

  async signInWithEmail(email: string, password: string) {
    try {
      const { data, error } = await this.client.auth.signInWithPassword({
        email,
        password,
      });

      if (error) throw error;

      console.log('‚úÖ Email login successful:', email);
      return data;
    } catch (error) {
      console.error('‚ùå Email login failed:', error);
      throw error;
    }
  }

  async signInWithGoogle(googleUser: any) {
    try {
      // Google sign-in ile aldƒ±ƒüƒ±n ID token'ƒ± Supabase'e g√∂nder
      const { data, error } = await this.client.auth.signInWithIdToken({
        provider: 'google',
        token: googleUser.idToken,
      });

      if (error) throw error;

      // Create user profile if it doesn't exist
      if (data.user) {
        const existingProfile = await this.getUserProfile(data.user.id);
        if (!existingProfile) {
          await this.createUserProfile(
            data.user.id,
            data.user.email!,
            data.user.user_metadata.name || googleUser.user.name,
            'google'
          );
        }
      }

      console.log('‚úÖ Google login successful:', data.user?.email);
      return data;
    } catch (error) {
      console.error('‚ùå Google login failed:', error);
      throw error;
    }
  }

  async signOut() {
    try {
      const { error } = await this.client.auth.signOut();
      if (error) throw error;

      this.currentUser = null;
      console.log('‚úÖ Sign out successful');
    } catch (error) {
      console.error('‚ùå Sign out failed:', error);
      throw error;
    }
  }

  async resendEmailConfirmation(email: string) {
    try {
      const { error } = await this.client.auth.resend({
        type: 'signup',
        email: email
      });

      if (error) throw error;
      console.log('‚úÖ Email confirmation resent to:', email);
      return true;
    } catch (error) {
      console.error('‚ùå Resend email confirmation failed:', error);
      throw error;
    }
  }

  // Expose client for advanced operations
  get supabaseClient() {
    return this.client;
  }

  // Create gamification profile
  async createGamificationProfile(userId: string) {
    try {
      const { data, error } = await this.client
        .from('gamification_profiles')
        .insert({
          user_id: userId,
          streak_count: 0,
          healing_points: 0,
          level: 1
        })
        .select()
        .single();

      if (error) throw error;
      console.log('‚úÖ Gamification profile created:', userId);
      return data;
    } catch (error) {
      console.error('‚ùå Create gamification profile failed:', error);
      throw error;
    }
  }

  // User Profile Methods
  async createUserProfile(userId: string, email: string, name: string, provider: 'email' | 'google') {
    try {
      const { data, error } = await this.client
        .from('users')
        .insert({
          id: userId,
          email,
          name,
          provider,
        })
        .select()
        .single();

      if (error) throw error;

      console.log('‚úÖ User profile created:', email);
      return data;
    } catch (error) {
      console.error('‚ùå Create user profile failed:', error);
      throw error;
    }
  }

  async getUserProfile(userId: string): Promise<UserProfile | null> {
    try {
      const { data, error } = await this.client
        .from('users')
        .select('*')
        .eq('id', userId)
        .single();

      if (error && error.code !== 'PGRST116') throw error; // PGRST116 = no rows
      return data;
    } catch (error) {
      console.error('‚ùå Get user profile failed:', error);
      return null;
    }
  }

  // OCD Profile Methods
  async saveOCDProfile(profile: Omit<OCDProfile, 'id' | 'created_at'>) {
    try {
      const { data, error } = await this.client
        .from('user_profiles')
        .upsert(profile)
        .select()
        .single();

      if (error) throw error;

      console.log('‚úÖ OCD profile saved');
      return data;
    } catch (error) {
      console.error('‚ùå Save OCD profile failed:', error);
      throw error;
    }
  }

  async getOCDProfile(userId: string): Promise<OCDProfile | null> {
    try {
      const { data, error } = await this.client
        .from('user_profiles')
        .select('*')
        .eq('user_id', userId)
        .single();

      if (error && error.code !== 'PGRST116') throw error;
      return data;
    } catch (error) {
      console.error('‚ùå Get OCD profile failed:', error);
      return null;
    }
  }

  // Compulsion Methods
  async addCompulsion(compulsion: Omit<CompulsionRecord, 'id' | 'timestamp'>) {
    try {
      const { data, error } = await this.client
        .from('compulsions')
        .insert({
          ...compulsion,
          timestamp: new Date().toISOString(),
        })
        .select()
        .single();

      if (error) throw error;

      console.log('‚úÖ Compulsion added');
      return data;
    } catch (error) {
      console.error('‚ùå Add compulsion failed:', error);
      throw error;
    }
  }

  async getCompulsions(userId: string, startDate?: string, endDate?: string) {
    try {
      let query = this.client
        .from('compulsions')
        .select('*')
        .eq('user_id', userId)
        .order('timestamp', { ascending: false });

      if (startDate) query = query.gte('timestamp', startDate);
      if (endDate) query = query.lte('timestamp', endDate);

      const { data, error } = await query;

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('‚ùå Get compulsions failed:', error);
      return [];
    }
  }

  // ERP Session Methods
  async addERPSession(session: Omit<ERPSession, 'id' | 'timestamp'>) {
    try {
      const { data, error } = await this.client
        .from('erp_sessions')
        .insert({
          ...session,
          timestamp: new Date().toISOString(),
        })
        .select()
        .single();

      if (error) throw error;

      console.log('‚úÖ ERP session added');
      return data;
    } catch (error) {
      console.error('‚ùå Add ERP session failed:', error);
      throw error;
    }
  }

  async getERPSessions(userId: string, startDate?: string, endDate?: string) {
    try {
      let query = this.client
        .from('erp_sessions')
        .select('*')
        .eq('user_id', userId)
        .order('timestamp', { ascending: false });

      if (startDate) query = query.gte('timestamp', startDate);
      if (endDate) query = query.lte('timestamp', endDate);

      const { data, error } = await query;

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('‚ùå Get ERP sessions failed:', error);
      return [];
    }
  }

  // Gamification Methods
  async updateGamificationProfile(profile: Partial<GamificationProfile> & { user_id: string }) {
    try {
      const { data, error } = await this.client
        .from('gamification_profiles')
        .upsert({
          ...profile,
          updated_at: new Date().toISOString(),
        })
        .select()
        .single();

      if (error) throw error;

      console.log('‚úÖ Gamification profile updated');
      return data;
    } catch (error) {
      console.error('‚ùå Update gamification profile failed:', error);
      throw error;
    }
  }

  async getGamificationProfile(userId: string): Promise<GamificationProfile | null> {
    try {
      const { data, error } = await this.client
        .from('gamification_profiles')
        .select('*')
        .eq('user_id', userId)
        .single();

      if (error && error.code !== 'PGRST116') throw error;
      return data;
    } catch (error) {
      console.error('‚ùå Get gamification profile failed:', error);
      return null;
    }
  }

  // Utility Methods
  getCurrentUser(): User | null {
    return this.currentUser;
  }

  isAuthenticated(): boolean {
    return this.currentUser !== null;
  }

  // Real-time subscriptions (gelecekte eklenebilir)
  subscribeToCompulsions(userId: string, callback: (data: any) => void) {
    // Will implement later when needed
    console.log('Realtime subscriptions will be implemented later');
  }

  subscribeToERPSessions(userId: string, callback: (data: any) => void) {
    // Will implement later when needed  
    console.log('Realtime subscriptions will be implemented later');
  }

  // RPC Functions (stored procedures)
  async handleNewUser(payload: any) {
    // Implementation here
  }

  async handleUserProfileUpdate(payload: any) {
    // Implementation here
  }
}

// Singleton instance
export const supabaseService = new SupabaseService();

// Initialize on app start
export const initializeSupabase = async () => {
  try {
    const user = await supabaseService.initialize();
    return user;
  } catch (error) {
    console.error('Failed to initialize Supabase:', error);
    return null;
  }
};
